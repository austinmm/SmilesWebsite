# Smile Warmup Project - CptS322 - Fall2018

## Part 3: Backend

Last part of the warmup project!     
Now you'll get to build your own server for the API and also hook it into your frontend app. 
**We provide you an example RESTful web service [people.py](https://gist.github.com/t-walker/29e5a2a5b0c6b2a03ba2e9084182cfa4)** using Python and the Flask microframework to get you started. 

If you would like to view a [tutorial] on Flask(https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world) for reference please do so.

**Deploying the application to Heroku is a non-trivial step, do not leave it for the last minute.**

   You will be deploying your application on Heroku and you will have to submit    the Heroku app URL to us. 
   
---
### Task 0: Git branch structure
---

You will have to develop the backend in the same working tree that you used
for Part 1 and Part 2, so that you can submit your code to the same git
repository.

1. Checkout to part3 branch (part3 branch already exists)

    ```
    git checkout part3
    ```
2. Merge your changes from part3 branch to part3. (Your current branch is part3)

    ```
    git merge part2
    ```
3. You will now be editing locally. If you need to move the files that you had for Part 2, feel free to do so. And **remember to commit frequently**. 

---
Task 1: Setup Flask on your `localhost`
---
1. If you haven't yet, go ahead and install [Python](https://www.python.org/downloads/). (Your Python version should be 3.4.x or higher. Latest version is 3.7.0)

      **Important** (Windows users):
      Please make sure to add the Python path to Windows Path. Read more [here](https://superuser.com/questions/143119/how-to-add-python-to-the-windows-path).
      Also, Windows installer now includes an option to add python.exe to the system search path. When you install Python, [select the "Add Python 3.x to PATH" option](https://www.google.com/url?sa=i&rct=j&q=&esrc=s&source=images&cd=&cad=rja&uact=8&ved=0ahUKEwit9NyWmafWAhXH44MKHaV9CfkQjRwIBw&url=https%3A%2F%2Floadbalancerblog.com%2Fblog%2F2015%2F11%2Fpython-35-install&psig=AFQjCNG10siDMl9gL49FY-3IQHICIPD2pw&ust=1505565091140981). If selected, the install directory will be added to your PATH.

2. If your system is Windows, open the GitBash; if Mac or Linux, open a terminal. 
   Run the following commands to install flask and flask-sqlalchemy. 

    on `Windows`:
    ```
    pip install flask
    pip install flask-sqlalchemy
    ```
    on `Mac/Linux`:
    ```
    pip3 install flask
    pip3 install flask-sqlalchemy
    ```
    Please don't install `flask` on a `virtualenv`.
    
    Note for Windows users: If `pip` is not installed in your system, you need to also add the Python\Scripts path to the Windows Path. On Windows, Python will typically be installed under the directory `C:\Users\<username>\AppData\Local\Programs\Python\Python3.x`. Locate your Python installation directory, make sure `pip` is under the `Scripts` directory, and add the "path of Scripts directory" to the Windows Path. 
         
3. On GitBash/terminal go to the warmup project directory. Run the following commands to create the application directory. Replace `<appname>` with the name of your application (e.g. SmileAPI)
    
    ```
    mkdir <appname>  
    cd <appname>
    ```
4. Under your `<appname>` directory create a script file called `requirements.txt` and which inludes the following commands.  `requirements.txt` specifies the  Python package dependencies needed for your application.
    ```
    flask
    flask-sqlalchemy
    flask-cors
    ```
    Install the requirements by running the following command:
    
    ```
    pip install -r requirements.txt
    ```

5. **Download [app.py](https://gist.github.com/t-walker/c15eb065eae6805de4057379dd35e786) into your app folder which has code to get you started.**

6. Run the following command to run your `app` on your `localhost`. 
    On Windows:
    ```
    python app.py 
    ```
    On Mac/Linux:
    ```
    python3 app.py 
    ```
---
Task 2: Create the Model
---
    You will have to create a single model (database table), called Smile, for your application. 

    The skeleton code we provided to you (`app.py`) already includes the code to setup a `sqlite` database via `SQLAlchemy` and create a model (table) called `Smile`.  

    The schema for the `Smile` table should look like this (this is a suggestion, although
    other schemas may work just as well):

    | Field name       | Field type  | Constraints | Comments
    ---------------|-----|-----|-----
    | id                      | integer        |   not null, primary key  | this should be autogenerated
    | space                | string          |   not null (at most 128 characters) 
    | title                   | string          |  not null (at most 64 characters)
    | story                 | string          |    not null (at most 2048 characters)
    | happiness_level  | integer       | not null
    | like_count          | integer        |   not null | Initialize to 0
    | created_at          | float            | not null | You can use some other representation of time , as long as it does not depend on the local timezone, and it allows for sub-second precision. 
    | updated_at        | float             |  not null | You can use some other representation of time, as long as it does not depend on the local timezone, and it allows for sub-second precision. 


    #### **TODO 1**:
    The skeleton code included the code to create `id` attribute for the smile table. You should write the code to add the other attributes listed above. Make sure to enforce the constraints specified for each attribute. 

    **Important Note:** When you run your server for the first time, if the database doesn't exist it will create it. If you run your code before you add all attributes, it will create the database with missing attributes. After you write the code to add the additional attributes , rm the file `sqlalchemy-demo.db` and re-run your code. This will remove the initial database created, and recreate the database with added attributes.   

---
Task 3: Create the Routes and Views
---
You can now proceed to write the code for implementing the API.


You will have to implement the following API entry points:

1. GET /api/smiles
    Read smiles. See specification in
    [Part2 - Task2](https://gitlab.eecs.wsu.edu/322-fall18-arslanay/warmup_project_322_skeleton/blob/part2/README_part2.md#Display-All-Smiles)
        
    *Example Request*
    `GET /api/smiles?space=initial&count=5&order_by=created_at`
        
    Part of the implementation for creating the route for `index` (i.e., loading all smiles) is provided to you in the skeleton code (`index()` function). Complete tasks TODO #1 and TODO #2 to order the retrieved stories based on the specified attribute value and to limit the number of stories. 

    #### **TODO 2**:
    Set the column which you are ordering on (if it exists)
      
    #### **TODO 3**:
    Limit the number of posts based on the count (if it exists)

2. POST /api/smiles/:id
    Loads a smile given the id as a value in the URL.
        *Example Request*
        `POST /api/smiles/4`
      
    #### **TODO 4**:
     Create the route for `show` to load a smile with the given id.   
      
3. POST /api/smiles
    Create a new smile.
    See specification in [Part 2- Task4](https://gitlab.eecs.wsu.edu/322-fall18-arslanay/warmup_project_322_skeleton/blob/part2/README_part2.md)
        *Example Request*
        `POST /api/smiles`
      
    #### **TODO 5**:
    Create the route for `create` to create a smile with the given JSON data.        
      
4. DELETE /api/smiles
    * Delete all the smiles in a smile space. See specification below.

    ##### Query Parameters
    ```
    space: the name of the smile space to delete.
            (mandatory, non-empty, at most 128 characters) 
    ```
    ##### Example Request
    ```
    DELETE /api/smiles?space=my_private_space
    ```
    ##### Example Response
    The response contains a status field (with value 1 if there were no errors, and -1 if there were errors).
    This is an example of a success response
    ```javascript
    {
        "status" : 1
    }
    ```
    If there were errors, then the response contains only two fields:
    ```javascript
    {
        "status" : -1,
        "errors" : [ ...list of error messages ... ]
    }
    ```
    #### **TODO 6**:
    Create the route for `delete_smiles`. Given a space name, all smiles in that space should be deleted.   
         
5. POST  /api/smiles/:id/like
    * Increment the like_count for a smile.
      See specification in [Part2 - Task3](https://gitlab.eecs.wsu.edu/322-fall18-arslanay/warmup_project_322_skeleton/blob/part2/README_part2.md)
      *Example Request*
      `POST /api/smiles/4/like`

    #### **TODO 7**:
    Create the route for `post_like`. Given an ID, it increments the `like-count' by 1 and loads the smile. ( *Note: please remember that after updating the `like_count`, you should send back the updated smile story.* )

##### Testing your API using Postman
You can use the [Postman tool](https://www.getpostman.com/postman) to test whether you set up the routes correctly. The responses your API returns should be similar to the responses you get from our backend `https://smile322.herokuapp.com` for the same requests.

---
Task 4: Prepare the Automated Tests  (**SKIP THIS TASK**)
---

    While you write the code for the API, I strongly recommend that you spend
    some time getting the automated tests ready. We are giving you a very simple
    test framework, written in Python, along with two automated tests. The grading
    of your project will be done with the same testing framework, except that we
    will have a lot more tests. You too should add automated tests to the
    framework. Writing automated tests, and experimenting with
    running them against the backend we provide will familiarize you with
    the more subtle corners of the API that you will have to implement. Plus,
    these tests will allow you to test your own backend.
    You will even be able to debug the corner cases of the API more easily
    because the automated tests allow you to reproduce such a corner
    case. For example, you may put a breakpoint in the debugger, and then
    fire the specific automated test that you are trying to get right.

    This development process is called **Test-Driven Development**.

    The testing framework is provided to you in the `testing` directory:
    * `testing/testLib.py`: this contains two classes, one which implements
        HTTP requests, and one that provides some helper functions for
        operating with smiles. You may want to add more helper functions
        to the `SmileTestCase` class.
        * By default, each test will first run the `setUp` method, defined
        in `testLib.SmileTestCase`. This method will **delete** all smile
        posts in the specified smile space. This is important, because
        you want all your tests to run in a predictable initial state.
        * Because of this, it is important to use a distinct smile space
        name from what other students will be using. All smiles in that
        space will be lost after running automated tests.
        
    * `testing/testBarely.py`: this file contains two test cases, to serve as
        an example for you. You should write more test cases.

    You invoke the tests as follows (on command line):
    ```
    python -m unittest
    ```
    OR
    ```
    python -m unittest  -v
    ```
    Passing the -v option to your test script will instruct unittest.main() to enable a higher level of verbosity. 
    
        * To enable the logging output, assign `VERBOSE` flag in `RestTestCase class` to 1 (in `testLib.py`). (If you use VERBOSE=1 you will see more detail about the messages that are sent/received. )
    
        * Update the `smileSpace` and `serverToTest` in  `RestTestCase class`. Current tests assume smile space `sakirenin` and 
        run against the server installed at `localhost` at port 5000.
        After deploying your app to Heroku, change the URL to your own. (Our  Heroku URL is `https://smile322.herokuapp.com`)
        * You can specify a single test to run by adding the argument as follows:
        ```python -m unittest  -v testBarely.TestSmiles.testAdd1```
        where `testAdd1` is the test we want to run. 


---
### Task 5: Setting-up your Flask App on Heroku
---
First we will include the commands to setup the enviroment on Heroku.

1. Edit the `requirements.txt` file and add the following  (don't delete the current commands).
    ```
    gunicorn
    ```
    Gunicorn is a pure-Python HTTP server. It allows you to run any Python application concurrently by running multiple Python processes within a single Heroku dyno. You don't need `gunicorn` when you run your server on the localhost.

2. Create the database file (`db_create.py`) which includes the following: 
    ```
    from app import db
    db.create_all()
    ```
    `db_create.py`  will create your database in Heroku.

5. Edit `app.py` and comment out the `db.create_all()` in function `main()`. 

    Heroku will run the `Procfile` to initialize the app, which will call `db_create.py` script to create the database. Therefore, there is no need to call `db.create_all()` in the `main`.

    Note: When you run the app on `localhost`, if you need to initialize the database, enable this line before you run `app.py`

6. Create the procfile file (`Procfile`)  and copy the following lines to the `Procfile`. 
    ```
    web: gunicorn app:app
    init: python db_create.py
    ```
    The `Procfile` will tell Heroku how to run your app.

7. Make sure the database file (`sqlalchemy-demo.db`) is in your local repo directory. 

Now we will login Heroku, create and deploy our app.

1. Create a Heroku account and install the [Heroku CLI (Heroku Command Line Interface)](https://devcenter.heroku.com/articles/heroku-cli). Login to Heroku by running the following command:
    <!-- -->
    ```
    heroku login
    ```
    
    **Note for Windows users:** If you get the following error message when you run `heroku login` on Git Bash, try running `login` and rest of the commands on Windows command line instead. 
    `Login is currently incompatible with git bash/Cywin/MinGW.`


2. Create an app on Heroku and give it a name. Your herokuappname should match with the name of your GitLab repo (i.e., yourlastname-warmup). 
    <!-- -->
    ```
    heroku create <yourlastname-warmup> 
    ```

    example: 'heroku create arslanay-warmup'
    (*yourlastname*-warmup should be an available app name. Contact the TAs if it is not available.)


8. Run these commands in your project directory to add and commit your code to Git:
    <!-- -->
    ```
    git add .
    ```

9. Commit your files 
    ```
    git commit -am "adding files for heroku deployment"
    ```

10. Push your application to Heroku
    ```
    git push heroku part3:master
    ```

    If there are no errors, your API should be deployed on Heroku. (eg: https://arslanay-warmup.herokuapp.com) To test whether your API on Heroku works, make GET and POST calls to your Heroku API using Postman. Replace the localhost address with the Heroku URL,i.e.,
    instad of 
    `http://localhost:5000/api/smiles`
    you should have:
    `https://arslanay-warmup.herokuapp.com/api/smiles`
    (assuming the application name is `arslanay-warmup`. You should replace this with the name you provided when you created the Heroku application i.e.,  `<herokuappname>` )

  If you get an error check the Heroku logs and troubleshoot the problems. See the below link.
  [https://devcenter.heroku.com/articles/logging](https://devcenter.heroku.com/articles/logging)
      
---
How to Submit
---

The deployment and submission steps for the backend are a bit more complex,
because you will need to deploy your code to Heroku as well as git.

1. You must ensure that your site works. We will be running automated tests on it. (Hint: try running the test yourself; there are no excuses if the test we gave you is failing. Of course, we expect that you would add more tests of your own.)

2.  Commit your changes locally. Make sure you are in branch `part3`.

    Push the `part3` branch to GitHub:
    ```
    git add .
    git commit -m "Your own commit message"
    git push origin part3
    ```
    * You can submit multiple times, after intermediate tasks, but on the deadline
      you need to have submitted the end result.
 
3. You must deploy your application to Heroku before the deadline. You can
follow the standard Heroku instructions, with the exception of `git init` (as
explained in Task 0 above) and the exact command to push your local repo to
Heroku. Since you are using local branch `part3` you need to run the following
command to push changes to Heroku:
    ```
    git push heroku part3:master
    ```
   You can deploy multiple times to Heroku, after intermediate tasks, but on the deadline you need to have submitted the end result.

4.	Create a Wiki page on Github and write your Heroku URL. See the [warmup_project_322_skeleton repo](https://gitlab.eecs.wsu.edu/322-fall18-arslanay/warmup_project_322_skeleton/wikis/Heroku-URL) for an example.      

    You are Done!
---

We hope you are smiling ! Let's get ready for the real project now. 



